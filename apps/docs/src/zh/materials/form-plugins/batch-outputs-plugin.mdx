import { SourceCode } from '@theme';
import { BasicStory, WithInferSchemaStory } from 'components/form-materials/form-plugins/batch-outputs-plugin';

# batchOutputsPlugin

`batchOutputsPlugin` æ˜¯ä¸€ä¸ªç”¨äºå¾ªç¯èŠ‚ç‚¹çš„è¡¨å•æ’ä»¶ï¼Œå®ƒå®ç°äº†ä¸¤ä¸ªæ ¸å¿ƒåŠŸèƒ½ï¼š

1. **è¾“å‡ºå˜é‡ç”Ÿæˆ**ï¼šå°†å¾ªç¯ä½“å†…æ”¶é›†çš„å˜é‡å¼•ç”¨è½¬æ¢ä¸ºæ•°ç»„ç±»å‹çš„è¾“å‡ºå˜é‡
2. **ä½œç”¨åŸŸé“¾è½¬æ¢**ï¼šè°ƒæ•´å˜é‡ä½œç”¨åŸŸé“¾ï¼Œä½¿å¾ªç¯èŠ‚ç‚¹çš„è¾“å‡ºèƒ½æ­£ç¡®ä¾èµ–å­èŠ‚ç‚¹çš„è¾“å‡º

**æ ¸å¿ƒç‰¹æ€§ï¼š**

- ğŸ”„ **æ•°ç»„åŒ…è£…**ï¼šè‡ªåŠ¨å°†å¾ªç¯ä½“å†…å¼•ç”¨çš„å˜é‡åŒ…è£…ä¸ºæ•°ç»„ç±»å‹è¾“å‡º
- ğŸ”— **ä½œç”¨åŸŸé“¾è°ƒæ•´**ï¼šè®©å¾ªç¯èŠ‚ç‚¹çš„è¾“å‡ºå˜é‡èƒ½æ­£ç¡®ä¾èµ–å­èŠ‚ç‚¹çš„è¾“å‡º
- ğŸ“Š **Schema æ¨å¯¼**ï¼šå¯é€‰é…ç½®ï¼Œè‡ªåŠ¨æ¨å¯¼è¾“å‡ºå˜é‡çš„ JSON Schema

:::tip{title="é€‚ç”¨åœºæ™¯"}

- **å¾ªç¯èŠ‚ç‚¹**ï¼šéœ€è¦åœ¨æ¯æ¬¡è¿­ä»£ä¸­æ”¶é›†æ•°æ®å¹¶èšåˆæˆæ•°ç»„
- **æ‰¹å¤„ç†èŠ‚ç‚¹**ï¼šéœ€è¦å°†å¤šä¸ªå­ä»»åŠ¡çš„ç»“æœæ±‡æ€»è¾“å‡º
- **ä»»ä½•åŒ…å«å­èŠ‚ç‚¹çš„å®¹å™¨èŠ‚ç‚¹**ï¼šéœ€è¦ä»å­èŠ‚ç‚¹æ”¶é›†è¾“å‡ºå˜é‡

:::

:::warning

`BatchOutputs` ç»„ä»¶å¿…é¡»æ­é… `batchOutputsPlugin` ä½¿ç”¨æ‰èƒ½æ­£å¸¸å·¥ä½œã€‚è¿™æ˜¯å› ä¸ºï¼š
1. ç»„ä»¶è´Ÿè´£ UI äº¤äº’ï¼Œæ”¶é›†ç”¨æˆ·é…ç½®çš„è¾“å‡ºé”®å€¼å¯¹
2. æ’ä»¶è´Ÿè´£å°†é…ç½®è½¬æ¢ä¸ºå˜é‡å£°æ˜ï¼Œå¹¶è°ƒæ•´ä½œç”¨åŸŸé“¾

:::

:::info{title="å®Œæ•´æ–¹æ¡ˆæ¦‚è§ˆ"}

å®ç°ä¸€ä¸ªå®Œæ•´çš„å¾ªç¯èŠ‚ç‚¹éœ€è¦ä»¥ä¸‹ä¸‰ä¸ªç‰©æ–™é…åˆä½¿ç”¨ï¼š

| ç‰©æ–™ | ç±»å‹ | èŒè´£ |
|------|------|------|
| [BatchVariableSelector](../components/batch-variable-selector) | ç»„ä»¶ | é€‰æ‹©å¾ªç¯çš„æ•°ç»„æ•°æ®æº |
| [provideBatchInputEffect](../effects/provide-batch-input) | å‰¯ä½œç”¨ | ç”Ÿæˆ `item` å’Œ `index` å±€éƒ¨å˜é‡ |
| [BatchOutputs](../components/batch-outputs) + **batchOutputsPlugin** | ç»„ä»¶ + æ’ä»¶ | é…ç½®å¾ªç¯è¾“å‡ºå¹¶ç”Ÿæˆæ•°ç»„ç±»å‹å˜é‡ |

:::

## æ¡ˆä¾‹æ¼”ç¤º

### åŸºæœ¬ä½¿ç”¨

:::tip

ç‚¹å¼€ demo å³ä¸Šè§’çš„ Debug é¢æ¿ï¼ŒæŸ¥çœ‹ç”Ÿæˆçš„è¾“å‡ºå˜é‡å’Œä¼ åˆ°åç«¯çš„ JSON æ•°æ®

:::

<BasicStory />

```tsx pure title="form-meta.tsx"
import { FormRenderProps, FlowNodeJSON, Field, FormMeta } from '@flowgram.ai/free-layout-editor';
import {
  BatchOutputs,
  BatchVariableSelector,
  createBatchOutputsFormPlugin,
  IFlowRefValue,
  provideBatchInputEffect,
} from '@flowgram.ai/form-materials';

interface LoopNodeJSON extends FlowNodeJSON {
  data: {
    loopFor: IFlowRefValue;
  };
}

export const LoopFormRender = ({ form }: FormRenderProps<LoopNodeJSON>) => {
  return (
    <>
      <FormHeader />
      <FormContent>
        <Field<IFlowRefValue> name="loopFor">
          {({ field, fieldState }) => (
            <FormItem name="loopFor" type="array" required>
              <BatchVariableSelector
                style={{ width: '100%' }}
                value={field.value?.content}
                onChange={(val) => field.onChange({ type: 'ref', content: val })}
                hasError={Object.keys(fieldState?.errors || {}).length > 0}
              />
            </FormItem>
          )}
        </Field>
        <Field<Record<string, IFlowRefValue | undefined> | undefined> name="loopOutputs">
          {({ field, fieldState }) => (
            <FormItem name="loopOutputs" type="object" vertical>
              <BatchOutputs
                style={{ width: '100%' }}
                value={field.value}
                onChange={(val) => field.onChange(val)}
                hasError={Object.keys(fieldState?.errors || {}).length > 0}
              />
            </FormItem>
          )}
        </Field>
      </FormContent>
    </>
  );
};

export const formMeta: FormMeta = {
  render: LoopFormRender,
  effect: {
    loopFor: provideBatchInputEffect,
  },
  plugins: [createBatchOutputsFormPlugin({ outputKey: 'loopOutputs', inferTargetKey: 'outputs' })],
};
```

:::info{title="å…³äº FormHeaderã€FormContentã€FormItem"}

ä¸Šè¿°ä»£ç ä¸­çš„ `FormHeader`ã€`FormContent`ã€`FormItem` æ˜¯ç”¨æˆ·è‡ªå®šä¹‰çš„å¸ƒå±€ç»„ä»¶ï¼Œç”¨äºç»Ÿä¸€è¡¨å•æ ·å¼ã€‚ä½ å¯ä»¥æ ¹æ®é¡¹ç›®éœ€æ±‚è‡ªè¡Œå®ç°æˆ–æ›¿æ¢ä¸ºå…¶ä»– UI ç»„ä»¶ã€‚

:::

### é…åˆ Schema æ¨å¯¼

<WithInferSchemaStory />

å½“é…ç½®äº† `inferTargetKey` å‚æ•°æ—¶ï¼Œæ’ä»¶ä¼šåœ¨è¡¨å•æäº¤æ—¶è‡ªåŠ¨æ¨å¯¼è¾“å‡ºå˜é‡çš„ JSON Schemaï¼Œå¹¶å­˜å‚¨åˆ°æŒ‡å®šå­—æ®µã€‚

## API å‚è€ƒ

### createBatchOutputsFormPlugin

åˆ›å»ºæ‰¹å¤„ç†è¾“å‡ºæ’ä»¶çš„å·¥å‚å‡½æ•°ã€‚

```typescript
function createBatchOutputsFormPlugin(options: {
  outputKey: string;
  inferTargetKey?: string;
}): FormPlugin;
```

| å±æ€§å | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|--------|------|--------|------|
| `outputKey` | `string` | - | è¡¨å•ä¸­å­˜å‚¨å¾ªç¯è¾“å‡ºé…ç½®çš„å­—æ®µè·¯å¾„ |
| `inferTargetKey` | `string` | - | å¯é€‰ï¼Œæ¨å¯¼çš„ JSON Schema å­˜å‚¨ä½ç½®çš„å­—æ®µè·¯å¾„ |

### provideBatchOutputsEffect

è¾“å‡ºå˜é‡ç”Ÿæˆå‰¯ä½œç”¨ï¼Œå°† `Record<string, IFlowRefValue>` æ ¼å¼çš„é…ç½®è½¬æ¢ä¸ºæ•°ç»„ç±»å‹çš„å˜é‡å£°æ˜ã€‚

```typescript
import { provideBatchOutputsEffect } from '@flowgram.ai/form-materials';

const formMeta: FormMeta = {
  effect: {
    loopOutputs: provideBatchOutputsEffect,
  },
};
```

:::tip

é€šå¸¸æƒ…å†µä¸‹ï¼Œä½¿ç”¨ `createBatchOutputsFormPlugin` å³å¯ï¼Œå®ƒå†…éƒ¨å·²ç»åŒ…å«äº† `provideBatchOutputsEffect`ã€‚åªæœ‰åœ¨éœ€è¦å•ç‹¬ä½¿ç”¨å˜é‡ç”ŸæˆåŠŸèƒ½è€Œä¸éœ€è¦ä½œç”¨åŸŸé“¾è½¬æ¢æ—¶ï¼Œæ‰éœ€è¦ç›´æ¥ä½¿ç”¨æ­¤å‰¯ä½œç”¨ã€‚

:::

## æºç å¯¼è¯»

<SourceCode
  href="https://github.com/bytedance/flowgram.ai/tree/main/packages/materials/form-materials/src/form-plugins/batch-outputs-plugin/index.ts"
/>

ä½¿ç”¨ CLI å‘½ä»¤å¯ä»¥å¤åˆ¶æºä»£ç åˆ°æœ¬åœ°ï¼š

```bash
npx @flowgram.ai/cli@latest materials form-plugins/batch-outputs-plugin
```

### ç›®å½•ç»“æ„è®²è§£

```
batch-outputs-plugin/
â””â”€â”€ index.ts           # æ’ä»¶å®Œæ•´å®ç°ï¼ŒåŒ…å«å˜é‡ç”Ÿæˆå’Œä½œç”¨åŸŸé“¾è½¬æ¢é€»è¾‘
```

### æ ¸å¿ƒå®ç°è¯´æ˜

#### æ’ä»¶ç»“æ„

`createBatchOutputsFormPlugin` ä½¿ç”¨ `defineFormPluginCreator` åˆ›å»ºï¼ŒåŒ…å«ä¸¤ä¸ªæ ¸å¿ƒç”Ÿå‘½å‘¨æœŸï¼š

1. **onSetupFormMeta**ï¼šé…ç½®è¡¨å•å…ƒæ•°æ®ï¼Œæ³¨å†Œå‰¯ä½œç”¨å’Œæäº¤æ ¼å¼åŒ–
2. **onInit**ï¼šåˆå§‹åŒ–æ—¶æ³¨å†Œä½œç”¨åŸŸé“¾è½¬æ¢å™¨

#### è¾“å‡ºå˜é‡ç”Ÿæˆ

`provideBatchOutputsEffect` å°† `Record<string, IFlowRefValue>` è½¬æ¢ä¸ºå˜é‡å£°æ˜ï¼š

```mermaid
graph LR
    A[loopOutputs é…ç½®] --> B[provideBatchOutputsEffect]
    B --> C[å˜é‡å£°æ˜]

    subgraph è½¬æ¢è¿‡ç¨‹
        D["{ names: { type: 'ref', content: ['item', 'name'] } }"]
        E["names: WrapArray(item.name)"]
        D --> E
    end

    C --> F[è¾“å‡º: names ç±»å‹ä¸º Array]
```

å…³é”®ç‚¹ï¼šä½¿ç”¨ `ASTFactory.createWrapArrayExpression` å°†å•ä¸ªå€¼ç±»å‹åŒ…è£…ä¸ºæ•°ç»„ç±»å‹ã€‚

#### ä½œç”¨åŸŸé“¾è½¬æ¢

è¿™æ˜¯è¯¥æ’ä»¶æœ€æ ¸å¿ƒçš„åŠŸèƒ½ï¼Œè§£å†³å¾ªç¯èŠ‚ç‚¹çš„å˜é‡ä½œç”¨åŸŸé—®é¢˜ã€‚

:::info{title="ä¸ºä»€ä¹ˆéœ€è¦ä½œç”¨åŸŸé“¾è½¬æ¢ï¼Ÿ"}

åœ¨é»˜è®¤çš„ä½œç”¨åŸŸé“¾é€»è¾‘ä¸­ï¼ˆå‚è€ƒ[ä½œç”¨åŸŸé“¾æ¦‚å¿µ](../../guide/variable/concept#ä½œç”¨åŸŸé“¾)ï¼‰ï¼š
- å­èŠ‚ç‚¹çš„è¾“å‡ºå˜é‡**ä¸èƒ½**è¢«çˆ¶èŠ‚ç‚¹çš„ä¸‹æ¸¸èŠ‚ç‚¹è®¿é—®
- å¾ªç¯èŠ‚ç‚¹çš„è¾“å‡ºå˜é‡**ä¸èƒ½**ä¾èµ–å­èŠ‚ç‚¹çš„è¾“å‡º

ä½†åœ¨å¾ªç¯åœºæ™¯ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ï¼š
- å¾ªç¯èŠ‚ç‚¹çš„è¾“å‡ºï¼ˆå¦‚èšåˆçš„æ•°ç»„ï¼‰èƒ½ä¾èµ–å­èŠ‚ç‚¹åœ¨æ¯æ¬¡è¿­ä»£ä¸­äº§ç”Ÿçš„å€¼
- å­èŠ‚ç‚¹çš„å˜é‡èƒ½"è¦†ç›–"åˆ°çˆ¶å¾ªç¯èŠ‚ç‚¹çš„ä½œç”¨åŸŸ

:::

ä¸‹å›¾å±•ç¤ºäº†ä½œç”¨åŸŸé“¾è½¬æ¢çš„å·¥ä½œåŸç†ï¼š

```mermaid
graph TB
    subgraph é»˜è®¤ä½œç”¨åŸŸé“¾
        direction TB
        A1[ä¸Šæ¸¸èŠ‚ç‚¹.scope] --> B1[å¾ªç¯èŠ‚ç‚¹.scope]
        B1 --> C1[ä¸‹æ¸¸èŠ‚ç‚¹.scope]
        B1 --> D1[å­èŠ‚ç‚¹.scope]
        D1 -.âŒ ä¸å¯è®¿é—®.-> C1
    end

    subgraph è½¬æ¢åçš„ä½œç”¨åŸŸé“¾
        direction TB
        A2[ä¸Šæ¸¸èŠ‚ç‚¹.scope] --> B2[å¾ªç¯èŠ‚ç‚¹.scope]
        B2 --> C2[ä¸‹æ¸¸èŠ‚ç‚¹.scope]
        B2 --> D2[å­èŠ‚ç‚¹.scope]
        D2 -.âœ… å¯è¦†ç›–.-> B2
        B2 -.ä¾èµ–.-> D2
    end
```

è½¬æ¢å™¨çš„ä¸¤ä¸ªæ ¸å¿ƒæ–¹æ³•ï¼š

| æ–¹æ³• | ä½œç”¨ | è¯´æ˜ |
|------|------|------|
| `transformCovers` | æ‰©å±•è¦†ç›–ä½œç”¨åŸŸ | è®©å­èŠ‚ç‚¹çš„å˜é‡å¯ä»¥"è¦†ç›–"åˆ°çˆ¶å¾ªç¯èŠ‚ç‚¹ |
| `transformDeps` | è°ƒæ•´ä¾èµ–ä½œç”¨åŸŸ | è®©å¾ªç¯èŠ‚ç‚¹çš„å…¬å…±ä½œç”¨åŸŸä¾èµ–å…¶å­èŠ‚ç‚¹çš„ä½œç”¨åŸŸ |

```mermaid
sequenceDiagram
    participant Loop as å¾ªç¯èŠ‚ç‚¹
    participant Child as å­èŠ‚ç‚¹
    participant Transform as ScopeChainTransformService

    Note over Loop,Child: é—®é¢˜ï¼šå¾ªç¯èŠ‚ç‚¹è¾“å‡ºä¾èµ–å­èŠ‚ç‚¹è¾“å‡º

    Loop->>Transform: æ³¨å†Œè½¬æ¢å™¨

    Note over Transform: transformCoversï¼ˆè¦†ç›–å…³ç³»ï¼‰
    Child->>Transform: å­èŠ‚ç‚¹æŸ¥è¯¢è¦†ç›–ä½œç”¨åŸŸ
    Transform-->>Child: è¿”å› [çˆ¶å¾ªç¯èŠ‚ç‚¹ä½œç”¨åŸŸ]
    Note over Child: å­èŠ‚ç‚¹å˜é‡å¯è¦†ç›–çˆ¶å¾ªç¯èŠ‚ç‚¹

    Note over Transform: transformDepsï¼ˆä¾èµ–å…³ç³»ï¼‰
    Loop->>Transform: å¾ªç¯èŠ‚ç‚¹æŸ¥è¯¢ä¾èµ–ä½œç”¨åŸŸ
    Transform-->>Loop: è¿”å› [ç§æœ‰ä½œç”¨åŸŸ, ...å­èŠ‚ç‚¹ä½œç”¨åŸŸ]
    Note over Loop: å¾ªç¯èŠ‚ç‚¹è¾“å‡ºä¾èµ–å­èŠ‚ç‚¹è¾“å‡º
```

#### å…³é”®ä»£ç è§£æ

**1. å˜é‡ç”Ÿæˆé€»è¾‘**

```typescript
export const provideBatchOutputsEffect: EffectOptions[] = createEffectFromVariableProvider({
  parse: (value: Record<string, IFlowRefValue>, ctx) => [
    ASTFactory.createVariableDeclaration({
      key: `${ctx.node.id}`,
      type: ASTFactory.createObject({
        properties: Object.entries(value).map(([_key, value]) =>
          ASTFactory.createProperty({
            key: _key,
            initializer: ASTFactory.createWrapArrayExpression({
              wrapFor: ASTFactory.createKeyPathExpression({
                keyPath: value?.content || [],
              }),
            }),
          })
        ),
      }),
    }),
  ],
});
```

**2. ä½œç”¨åŸŸé“¾è½¬æ¢å™¨**

```typescript
chainTransformService.registerTransformer(transformerId, {
  transformCovers: (covers, ctx) => {
    const node = ctx.scope.meta?.node;
    if (node?.parent?.flowNodeType === batchNodeType) {
      return [...covers, getNodeScope(node.parent)];
    }
    return covers;
  },
  transformDeps(scopes, ctx) {
    const scopeMeta = ctx.scope.meta;
    if (scopeMeta?.type === FlowNodeScopeType.private) {
      return scopes;
    }
    const node = scopeMeta?.node;
    if (node?.flowNodeType === batchNodeType) {
      const childBlocks = node.blocks;
      return [
        getNodePrivateScope(node),
        ...childBlocks.map((_childBlock) => getNodeScope(_childBlock)),
      ];
    }
    return scopes;
  },
});
```

**3. Schema æ¨å¯¼ï¼ˆå¯é€‰ï¼‰**

```typescript
if (inferTargetKey) {
  addFormatOnSubmit((formData, ctx) => {
    const outputVariable = getNodeScope(ctx.node).output.variables?.[0];
    if (outputVariable?.type) {
      set(formData, inferTargetKey, JsonSchemaUtils.astToSchema(outputVariable?.type));
    }
    return formData;
  });
}
```

### ä¾èµ–æ¢³ç†

#### flowgram API

[**@flowgram.ai/editor**](https://github.com/bytedance/flowgram.ai/tree/main/packages/client/editor)
- `defineFormPluginCreator`: å®šä¹‰è¡¨å•æ’ä»¶çš„å·¥å‚å‡½æ•°
- `EffectOptions`: è¡¨å•å‰¯ä½œç”¨é€‰é¡¹ç±»å‹
- `createEffectFromVariableProvider`: ä»å˜é‡æä¾›å™¨åˆ›å»ºè¡¨å•å‰¯ä½œç”¨
- `FlowNodeRegistry`: èŠ‚ç‚¹æ³¨å†Œç±»å‹å®šä¹‰
- `FlowNodeScopeType`: èŠ‚ç‚¹ä½œç”¨åŸŸç±»å‹æšä¸¾
- `getNodeScope`: è·å–èŠ‚ç‚¹çš„å…¬å…±ä½œç”¨åŸŸ
- `getNodePrivateScope`: è·å–èŠ‚ç‚¹çš„ç§æœ‰ä½œç”¨åŸŸ
- `ScopeChainTransformService`: ä½œç”¨åŸŸé“¾è½¬æ¢æœåŠ¡

[**@flowgram.ai/variable-core**](https://github.com/bytedance/flowgram.ai/tree/main/packages/variable-engine/variable-core)
- `ASTFactory`: AST åˆ›å»ºå·¥å‚
- `ASTFactory.createWrapArrayExpression`: åˆ›å»ºæ•°ç»„åŒ…è£…è¡¨è¾¾å¼

[**@flowgram.ai/json-schema**](https://github.com/bytedance/flowgram.ai/tree/main/packages/variable-engine/json-schema)
- `JsonSchemaUtils.astToSchema`: å°† AST è½¬æ¢ä¸º JSON Schema

#### ä¾èµ–çš„å…¶ä»–ç‰©æ–™

[**BatchOutputs**](../components/batch-outputs)
- å¾ªç¯è¾“å‡ºé…ç½®ç»„ä»¶ï¼Œç”¨äºæ”¶é›†è¾“å‡ºé”®å€¼å¯¹

[**BatchVariableSelector**](../components/batch-variable-selector)
- æ•°ç»„å˜é‡é€‰æ‹©å™¨ï¼Œç”¨äºé€‰æ‹©å¾ªç¯è¾“å…¥

[**provideBatchInputEffect**](../effects/provide-batch-input)
- å¾ªç¯è¾“å…¥å‰¯ä½œç”¨ï¼Œç”Ÿæˆ item å’Œ index å±€éƒ¨å˜é‡

## å¸¸è§é—®é¢˜

### ä¸ºä»€ä¹ˆéœ€è¦åŒæ—¶ä½¿ç”¨ BatchOutputs ç»„ä»¶å’Œ batchOutputsPluginï¼Ÿ

è¿™æ˜¯å…³æ³¨ç‚¹åˆ†ç¦»çš„è®¾è®¡ï¼š

| è§’è‰² | èŒè´£ |
|------|------|
| `BatchOutputs` ç»„ä»¶ | æä¾› UI äº¤äº’ï¼Œè®©ç”¨æˆ·é…ç½®è¾“å‡ºé”®åå’Œå˜é‡å¼•ç”¨ |
| `batchOutputsPlugin` | å¤„ç†æ•°æ®é€»è¾‘ï¼Œå°†é…ç½®è½¬æ¢ä¸ºå˜é‡å£°æ˜å¹¶è°ƒæ•´ä½œç”¨åŸŸé“¾ |

å•ç‹¬ä½¿ç”¨ç»„ä»¶åªèƒ½æ”¶é›†æ•°æ®ï¼Œæ— æ³•ç”Ÿæˆæœ‰æ•ˆçš„è¾“å‡ºå˜é‡ï¼›å•ç‹¬ä½¿ç”¨æ’ä»¶åˆ™æ²¡æœ‰ UI æ¥é…ç½®æ•°æ®ã€‚

### ä»€ä¹ˆæ—¶å€™éœ€è¦é…ç½® inferTargetKeyï¼Ÿ

å½“ä½ éœ€è¦å°†è¾“å‡ºå˜é‡çš„ç±»å‹ä¿¡æ¯æŒä¹…åŒ–åˆ°è¡¨å•æ•°æ®ä¸­æ—¶ï¼ˆä¾‹å¦‚åç«¯éœ€è¦çŸ¥é“è¾“å‡ºçš„ JSON Schemaï¼‰ï¼Œé…ç½® `inferTargetKey` å¯ä»¥åœ¨è¡¨å•æäº¤æ—¶è‡ªåŠ¨æ¨å¯¼å¹¶å­˜å‚¨ Schemaã€‚

### å¦‚ä½•ä¸ provideBatchInputEffect é…åˆä½¿ç”¨ï¼Ÿ

å®Œæ•´çš„å¾ªç¯èŠ‚ç‚¹é€šå¸¸è¿™æ ·é…ç½®ï¼š

```typescript
export const formMeta: FormMeta = {
  render: LoopFormRender,
  effect: {
    loopFor: provideBatchInputEffect,
  },
  plugins: [
    createBatchOutputsFormPlugin({
      outputKey: 'loopOutputs',
      inferTargetKey: 'outputs'
    })
  ],
};
```

- `provideBatchInputEffect` è´Ÿè´£ä»å¾ªç¯è¾“å…¥æ•°ç»„ç”Ÿæˆ `item` å’Œ `index` å±€éƒ¨å˜é‡
- `batchOutputsPlugin` è´Ÿè´£å°†å¾ªç¯ä½“å†…æ”¶é›†çš„å˜é‡èšåˆä¸ºæ•°ç»„è¾“å‡º

### ä½œç”¨åŸŸé“¾è½¬æ¢ä¼šå½±å“å…¶ä»–èŠ‚ç‚¹å—ï¼Ÿ

ä¸ä¼šã€‚è½¬æ¢å™¨é€šè¿‡ `batchNodeType` ç²¾ç¡®åŒ¹é…å½“å‰èŠ‚ç‚¹ç±»å‹ï¼Œåªå¯¹è¯¥ç±»å‹çš„èŠ‚ç‚¹ç”Ÿæ•ˆã€‚è½¬æ¢å™¨ ID ä¹ŸåŒ…å«èŠ‚ç‚¹ç±»å‹ï¼Œé¿å…é‡å¤æ³¨å†Œã€‚

## ç›¸å…³ç‰©æ–™

- [provideBatchInputEffect](../effects/provide-batch-input): å¾ªç¯è¾“å…¥å˜é‡è§£æ
- [BatchOutputs](../components/batch-outputs): å¾ªç¯è¾“å‡ºé…ç½®ç»„ä»¶
- [BatchVariableSelector](../components/batch-variable-selector): æ•°ç»„å˜é‡é€‰æ‹©å™¨
- [inferInputsPlugin](./infer-inputs-plugin): è¾“å…¥å‚æ•° Schema æ¨å¯¼æ’ä»¶
